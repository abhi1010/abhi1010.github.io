<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bash on Coders Digest</title>
    <link>http://abhipandey.com/tags/bash/</link>
    <description>Recent content in Bash on Coders Digest</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 18 Mar 2016 20:20:21 +0800</lastBuildDate>
    <atom:link href="http://abhipandey.com/tags/bash/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>getopt vs getopts</title>
      <link>http://abhipandey.com/2016/03/getopt-vs-getopts/</link>
      <pubDate>Fri, 18 Mar 2016 20:20:21 +0800</pubDate>
      
      <guid>http://abhipandey.com/2016/03/getopt-vs-getopts/</guid>
      <description>

&lt;p&gt;Should you use &lt;code&gt;getopt&lt;/code&gt; or &lt;code&gt;getopts&lt;/code&gt; in your bash scripts?&lt;/p&gt;

&lt;p&gt;The answer can be a bit tricky but mostly straight forward.&lt;/p&gt;

&lt;h2 id=&#34;getopt:dd7aaebbdbc744c7f56cf7dcd59142a2&#34;&gt;getopt&lt;/h2&gt;

&lt;p&gt;Generally, try to stay away from &lt;strong&gt;getopt&lt;/strong&gt; for the following reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;External utility&lt;/li&gt;
&lt;li&gt;Traditional versions can&amp;rsquo;t handle empty argument strings, or arguments with embedded whitespace&lt;/li&gt;
&lt;li&gt;For the loops to work perfectly, you must provide the values in the same sequence as the for loop itself; which is
very hard to control&lt;/li&gt;
&lt;li&gt;Mostly a way to standardize the parameters&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The only time I could think of using &lt;em&gt;getopt&lt;/em&gt; is when I really want to use a long variable name and there&amp;rsquo;s just a single one.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;a a sample for &lt;em&gt;getopt&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

#Check the number of arguments. If none are passed, print help and exit.
NUMARGS=$#
# echo -e \\n&amp;quot;Number of arguments: $NUMARGS&amp;quot;
if [ $NUMARGS -eq 0 ]; then
  HELP
fi

OPTS=`getopt -o vhns: --long verbose,dry-run,help,stack-size: -n &#39;parse-options&#39; -- &amp;quot;$@&amp;quot;`

eval set -- &amp;quot;$OPTS&amp;quot;

while getopt dir:,env: FLAG; do
  case $FLAG in
    -dir)
      DIR=$OPTARG
      echo &amp;quot;-dir used: $OPTARG&amp;quot;
      ;;
    -env)
      PYENV=$OPTARG
      echo &amp;quot;-env used: $OPTARG&amp;quot;
      ;;
    h)  #show help
      HELP
      ;;
    \?) #unrecognized option - show help
      echo -e \\n&amp;quot;Option -${BOLD}$OPTARG${NORM} not allowed.&amp;quot;
      HELP
      ;;
  esac
done

shift $((OPTIND-1))  #This tells getopts to move on to the next argument.

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getopts:dd7aaebbdbc744c7f56cf7dcd59142a2&#34;&gt;getopts&lt;/h2&gt;

&lt;p&gt;Whereas, &lt;strong&gt;getopts&lt;/strong&gt; is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Portable and works in any POSIX shell&lt;/li&gt;
&lt;li&gt;Lenient with usage of &amp;ldquo;-a -b&amp;rdquo; as well as &amp;ldquo;-ab&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Understands &amp;ldquo;&amp;ndash;&amp;rdquo; as the option terminator&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here&amp;rsquo;s a sample for &lt;em&gt;getopts&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
SCRIPT=`basename ${BASH_SOURCE[0]}`

## Let&#39;s do some admin work to find out the variables to be used here
BOLD=&#39;\e[1;31m&#39;         # Bold Red
REV=&#39;\e[1;32m&#39;       # Bold Green

#Help function
function HELP {
  echo -e &amp;quot;${REV}Basic usage:${OFF} ${BOLD}$SCRIPT -d helloworld ${OFF}&amp;quot;\\n
  echo -e &amp;quot;${REV}The following switches are recognized. $OFF &amp;quot;
  echo -e &amp;quot;${REV}-p ${OFF}  --Sets the environment to use for installing python ${OFF}. Default is ${BOLD} /usr/bin ${OFF}&amp;quot;
  echo -e &amp;quot;${REV}-d ${OFF}  --Sets the directory whose virtualenv is to be setup. Default is ${BOLD} local folder (.) ${OFF}&amp;quot;
  echo -e &amp;quot;${REV}-v ${OFF}  --Sets the python version that you want to install. Default is ${BOLD} 2.7 ${OFF}&amp;quot;
  echo -e &amp;quot;${REV}-h${OFF}  --Displays this help message. No further functions are performed.&amp;quot;\\n
  echo -e &amp;quot;Example: ${BOLD}$SCRIPT -d helloworld -p /opt/py27env/bin -v 2.7 ${OFF}&amp;quot;\\n
  exit 1
}

PYENV=&#39;/usr/bin&#39;
DIR=&#39;.&#39;
VERSION=&#39;2.7&#39;

# In case you wanted to check what variables were passed
# echo &amp;quot;flags = $*&amp;quot;

while getopts p:d:v:h FLAG; do
  case $FLAG in
    d)
      DIR=$OPTARG
      ;;
    p)
      PYENV=$OPTARG
      ;;
    v)
      VERSION=$OPTARG
      ;;
    h)
      HELP
      ;;
    \?) #unrecognized option - show help
      echo -e \\n&amp;quot;Option -${BOLD}$OPTARG${OFF} not allowed.&amp;quot;
      HELP
      ;;
  esac
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;what-if-i-really-wanted-long-options-with-getopts:dd7aaebbdbc744c7f56cf7dcd59142a2&#34;&gt;What if I really wanted long options with &lt;em&gt;getopts&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;getopts&lt;/em&gt; function can be used to parse long options by putting a dash character followed by a colon into the OPTSPEC.
Sharing &lt;a href=&#34;http://stackoverflow.com/a/7680682/142650&#34;&gt;the solution from this link&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/env bash 
OPTSPEC=&amp;quot;:hv-:&amp;quot;
while getopts &amp;quot;$OPTSPEC&amp;quot; optchar; do
    case &amp;quot;${optchar}&amp;quot; in
        -)
            case &amp;quot;${OPTARG}&amp;quot; in
                loglevel)
                    val=&amp;quot;${!OPTIND}&amp;quot;; OPTIND=$(( $OPTIND + 1 ))
                    echo &amp;quot;Parsing option: &#39;--${OPTARG}&#39;, value: &#39;${val}&#39;&amp;quot; &amp;gt;&amp;amp;2;
                    ;;
                loglevel=*)
                    val=${OPTARG#*=}
                    opt=${OPTARG%=$val}
                    echo &amp;quot;Parsing option: &#39;--${opt}&#39;, value: &#39;${val}&#39;&amp;quot; &amp;gt;&amp;amp;2
                    ;;
                *)
                    if [ &amp;quot;$OPTERR&amp;quot; = 1 ] &amp;amp;&amp;amp; [ &amp;quot;${OPTSPEC:0:1}&amp;quot; != &amp;quot;:&amp;quot; ]; then
                        echo &amp;quot;Unknown option --${OPTARG}&amp;quot; &amp;gt;&amp;amp;2
                    fi
                    ;;
            esac;;
        h)
            echo &amp;quot;usage: $0 [-v] [--loglevel[=]&amp;lt;value&amp;gt;]&amp;quot; &amp;gt;&amp;amp;2
            exit 2
            ;;
        v)
            echo &amp;quot;Parsing option: &#39;-${optchar}&#39;&amp;quot; &amp;gt;&amp;amp;2
            ;;
        *)
            if [ &amp;quot;$OPTERR&amp;quot; != 1 ] || [ &amp;quot;${OPTSPEC:0:1}&amp;quot; = &amp;quot;:&amp;quot; ]; then
                echo &amp;quot;Non-option argument: &#39;-${OPTARG}&#39;&amp;quot; &amp;gt;&amp;amp;2
            fi
            ;;
    esac
done
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Color your process listings</title>
      <link>http://abhipandey.com/2016/02/color-your-process-listings/</link>
      <pubDate>Tue, 09 Feb 2016 17:00:59 +0800</pubDate>
      
      <guid>http://abhipandey.com/2016/02/color-your-process-listings/</guid>
      <description>&lt;p&gt;Many a times I am grepping for a process that is running on a prod server with lots of different configuration
parameters. However, since there are so many of them, it is very difficult to view a particular parameter itself
and find out what value was assigned to it. I wanted to make it easier on the eyes and decided to color code the
parameters and separate them out from the values.
Here&amp;rsquo;s the bash function I pulled out.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;colorme()
{
  gawk &#39;BEGIN {RS=&amp;quot; --| -&amp;quot;; }{print $0}&#39; \
  | sed -e &#39;s/\([[:alpha:]]\+\)=/\1 /g&#39; \
  | gawk &#39;BEGIN    {printf &amp;quot;-----------------\n&amp;quot; ; }
            {
                if (NF &amp;gt; 2) printf &amp;quot;\n\033[41;5;1m%s\033[0m\n&amp;quot;, $NF ;
                printf &amp;quot;\033[40;38;5;82m  %30s  \033[38;5;198m %s \033[0m \n&amp;quot;, $1, $2
            }&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The idea is as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Have a bash function that can be piped onto any command; perhaps &lt;code&gt;ps -ef&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Paragraph style viewing for each process&lt;/li&gt;
&lt;li&gt;Break down every parameter into separate lines using &lt;code&gt;gawk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;sed&lt;/code&gt; to convert config params in the &lt;code&gt;--rate=10&lt;/code&gt; into something like &lt;code&gt;rate 10&lt;/code&gt;, just like others&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;gawk&lt;/code&gt; again to add colors on every pair of &lt;code&gt;key value&lt;/code&gt; line&lt;/li&gt;
&lt;li&gt;Keys are right aligned, green in color and values are right aligned, red in color so it&amp;rsquo;s very easy to view&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is a sample command I wanted to test out.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/opt/py27env/bin/python manage.py main-service-name --daemonize \
    --alias-svc=mainsvc01 --application-id=app03/mainsvc01 --monitoring-service-name=mainsvc01 \
    --log-level=DEBUG --solace-session-prop-host=server.prod --solace-session-prop-username=testing \
    --solace-session-prop-password=testing --solace-session-prop-vpn=testing \
    --solace-session-prop-cache-name=test_dc \
    --rate=10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the result from my tests:

&lt;figure &gt;
    
        &lt;img src=&#34;http://abhipandey.com/images/bash_process_color_coding_1.png&#34; alt=&#34;Color coded process listing&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Color coded process listing
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Powerline for zsh</title>
      <link>http://abhipandey.com/2015/09/powerline-for-zsh/</link>
      <pubDate>Mon, 28 Sep 2015 08:46:09 +0800</pubDate>
      
      <guid>http://abhipandey.com/2015/09/powerline-for-zsh/</guid>
      <description>
&lt;figure &gt;
    
        &lt;img src=&#34;http://abhipandey.com/images/powerline-for-zsh.png&#34; alt=&#34;Powerline&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        Powerline
        
            
        
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;I was having a lot of trouble getting &lt;a href=&#34;https://github.com/carlcarl/powerline-zsh&#34;&gt;&lt;em&gt;powerline&lt;/em&gt;&lt;/a&gt; to work on my mac machine.
No matter what I tried, I was getting errors like the following:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000; font-style: italic&#34;&gt;    .oh-my-zsh/themes/powerline.zsh-theme:100: character not in range&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally got it to work after multiple attempts on &lt;code&gt;bash&lt;/code&gt; and &lt;code&gt;zsh&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;All I had to do was set &lt;code&gt;LC_ALL&lt;/code&gt; to &lt;strong&gt;en_US.UTF-8&lt;/strong&gt;. It would set all the locales to &lt;code&gt;en_US.UTF-8&lt;/code&gt; which
would allow &lt;code&gt;powerline&lt;/code&gt; fonts work properly.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span style=&#34;color: #204a87&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color: #000000&#34;&gt;LC_ALL&lt;/span&gt;&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;quot;en_US.UTF-8&amp;quot;&lt;/span&gt;                                                                                                     22:58:06 
$ locale 
&lt;span style=&#34;color: #000000&#34;&gt;LANG&lt;/span&gt;&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;
&lt;span style=&#34;color: #000000&#34;&gt;LC_COLLATE&lt;/span&gt;&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;quot;en_US.UTF-8&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #000000&#34;&gt;LC_CTYPE&lt;/span&gt;&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;quot;en_US.UTF-8&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #000000&#34;&gt;LC_MESSAGES&lt;/span&gt;&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;quot;en_US.UTF-8&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #000000&#34;&gt;LC_MONETARY&lt;/span&gt;&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;quot;en_US.UTF-8&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #000000&#34;&gt;LC_NUMERIC&lt;/span&gt;&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;quot;en_US.UTF-8&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #000000&#34;&gt;LC_TIME&lt;/span&gt;&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;quot;en_US.UTF-8&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #000000&#34;&gt;LC_ALL&lt;/span&gt;&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;quot;en_US.UTF-8&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After this, run the following command to test your fonts again.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000&#34;&gt;LC_CTYPE&lt;/span&gt;&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;en_US.UTF-8 &lt;span style=&#34;color: #204a87&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;#39;\u2603&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Your command should work with or without &lt;code&gt;LC_CTYPE=en_US.UTF-8&lt;/code&gt;. Here&amp;rsquo;s what you expect to see now.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;    ☃
&lt;/pre&gt;&lt;/div&gt;

</description>
    </item>
    
    <item>
      <title>Git LOC Stats by Time Range</title>
      <link>http://abhipandey.com/2015/09/git-loc-stats-by-time-range/</link>
      <pubDate>Thu, 17 Sep 2015 11:06:06 +0800</pubDate>
      
      <guid>http://abhipandey.com/2015/09/git-loc-stats-by-time-range/</guid>
      <description>&lt;p&gt;Recently had an interest in seeing how many LOC were committed to the code base over a particular period of
time. After some tinkering around, mainly to find out the correct format for time ranges, decided to use the following bash script for finding coding stats.
Following sample is to find out lines added or removed during the year 2014.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;$ git log --after&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;quot;2014-1-1&amp;quot;&lt;/span&gt; --before&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;quot;2014-12-31&amp;quot;&lt;/span&gt; --pretty&lt;span style=&#34;color: #ce5c00; font-weight: bold&#34;&gt;=&lt;/span&gt;tformat: --numstat 
    &lt;span style=&#34;color: #000000; font-weight: bold&#34;&gt;|&lt;/span&gt; awk &lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;#39;{ if ( $2 != 0 &amp;amp;&amp;amp; $1 != 0 ) print $0 }&amp;#39;&lt;/span&gt; 
    &lt;span style=&#34;color: #000000; font-weight: bold&#34;&gt;|&lt;/span&gt; gawk &lt;span style=&#34;color: #4e9a06&#34;&gt;&amp;#39;{ add += $1; subs += $2; loc += $1 - $2 } END { printf &amp;quot;Added lines: %s Removed lines: %s Total # of lines: %s\n&amp;quot;, add, subs, loc }&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The result will be as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Added lines: 327505 Removed lines: 243860 Total # of lines: 83645
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will notice in the second line that I am doing the following:
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #000000; font-style: italic&#34;&gt; if ( $2 != 0 &amp;amp;&amp;amp; $1 != 0 ) &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;This is simply to discard off any commit numbers that were pure addition or deletion (with no corresponding delete or add in the same commit).
It may also remove some numbers that were actually valid commits but mostly it is to protect ourselves against any library or API that we may have added or replaced during that time period.&lt;/p&gt;

&lt;p&gt;For time range, you may even use something like &lt;code&gt;--since=&amp;quot;1 year ago&amp;quot;&lt;/code&gt; and that will also yield similar results.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setting up your VIM... Your style</title>
      <link>http://abhipandey.com/2014/05/setting-up-your-vim...-your-style/</link>
      <pubDate>Mon, 19 May 2014 15:51:51 +0000</pubDate>
      
      <guid>http://abhipandey.com/2014/05/setting-up-your-vim...-your-style/</guid>
      <description>&lt;p&gt;Writing code using VIM can be a bit overwhelming but it helps creating a few shortcuts there to make your life easier. Here I will discuss a few.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First of all, it is always a good idea to set up your tabs and spaces&lt;/li&gt;
&lt;li&gt;Set up shortcuts for:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Toggling of Auto-Indent&lt;/code&gt; while pasting source text; very useful in code (&lt;em&gt;F2&lt;/em&gt; in my provided script)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Toggling of Auto-Scroll&lt;/code&gt; of Split windows (&lt;em&gt;F3&lt;/em&gt; in my provided script)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Macro for Folding functions&lt;/code&gt; within the source code (&lt;em&gt;&lt;em&gt;@q&lt;/em&gt;&lt;/em&gt; in my provided script)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Smart case search&lt;/code&gt; - based on whether the input is in caps or not&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Toggling of Mouse Usage&lt;/code&gt; in VIM window - to allow quick selection of text (&lt;em&gt;F12&lt;/em&gt; in my provided script)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please see the provided script below to have a look.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;http://gist.github.com/6f190c9f3afd42881ef5.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Getting a group of lines from a file</title>
      <link>http://abhipandey.com/2014/05/getting-a-group-of-lines-from-a-file/</link>
      <pubDate>Mon, 19 May 2014 09:45:57 +0000</pubDate>
      
      <guid>http://abhipandey.com/2014/05/getting-a-group-of-lines-from-a-file/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve had this need quite a few times to pull out a section of logs that would begin with a particular line and end with another. grep is not exactly useful there because it only prints out sections based on line counters (using -A/B/C) lines based on a single search pattern.&lt;/p&gt;

&lt;p&gt;I came up with a script that can run at almost same speeds using &lt;code&gt;grep/cat/awk&lt;/code&gt;. &lt;code&gt;awk&lt;/code&gt; is used to decide whether the end of the section has been reached or not. Some features of the script are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Since &lt;code&gt;awk&lt;/code&gt; script only toggles one variable it works seamlessly without delaying the actual work&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Works on gzip files as well&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you do not want to depend on grep or are unsure how many lines may be between begin and end keyword then replace gunzip with zcat and grep with cat.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Usage: &lt;code&gt;group filename printBeginKeyword printUntilKeyword NumOfLines&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at the script&amp;hellip;.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;http://gist.github.com/924a5f12f3067ba0b3af.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Global Search in VIM</title>
      <link>http://abhipandey.com/2014/02/global-search-in-vim/</link>
      <pubDate>Tue, 11 Feb 2014 14:56:00 +0000</pubDate>
      
      <guid>http://abhipandey.com/2014/02/global-search-in-vim/</guid>
      <description>&lt;p&gt;You must be knowing about regular VIM search&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%s/SEARCH/REPLACE/CMD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, sometimes you do not want to replace something but just see all instances of the a word or phrase. In such cases, global search is really useful when on vim. The syntax is simpler than normal search-replace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:[range]g[lobal]/{pattern}/[cmd]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will show all instances of the &amp;ldquo;SEARCH&amp;rdquo; term within the VIM window. There&amp;rsquo;s another version of the same command which is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:[range]g[lobal]!/{pattern}/[cmd]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is similar to the previous command but the only difference is that this command contains &amp;ldquo;!&amp;rdquo; which signifies that the command will be executed on all lines &lt;code&gt;NOT&lt;/code&gt; matching the &lt;code&gt;pattern&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One example here would be to delete all lines in a file containing a particular word:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:g/deleteMe/d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There could be lot more actions (regular vim stuff) that you could do like yanking or indenting.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CVS Cheat Sheet</title>
      <link>http://abhipandey.com/2013/07/cvs-cheat-sheet/</link>
      <pubDate>Wed, 03 Jul 2013 07:28:00 +0000</pubDate>
      
      <guid>http://abhipandey.com/2013/07/cvs-cheat-sheet/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve worked on CVS for a long time now and figured out that I&amp;rsquo;d save a lot of time if I started writing alias or functions for the numerous tasks that I did on them. I will put down some of them here so you may benefit from them.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Silently update and inform about the status of the files (recursive)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cvs -q -n update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Same as earlier but will only do so for the current folder&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cvs -Q -n update -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Finds out the cv[s] [m]odified list of files while also indentating them nicely with only the important data pulled out&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cvs -Q status | egrep &amp;quot;File: &amp;quot; -A 4 | egrep -v &amp;quot;Up-to-date&amp;quot; | egrep &amp;quot;File: &amp;quot; -A 3 | sed -e &amp;quot;s/ Status:/\t\tStatus:/&amp;quot; -e &amp;quot;s/,v$/\n-------------------------------------------------------------------------\n/&amp;quot; -e &amp;quot;s/.*${PWD##*/}\//Location:\t\t /&amp;quot; -e &amp;quot;s/Attic\///&amp;quot; | egrep &amp;quot;Location:|Repository|Status:|File:|--------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Recursively add all files to CVS for committing from the current directory&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -type d -print | grep -v CVS | xargs cvs add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Doing a side by side diff (change the value of -W according to the width of the screen)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cvs -Q diff -t -y --suppress-common-lines -W 190 $*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Merging code from one branch to another&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Creates a command that you can use to &amp;quot;merge&amp;quot; your code from dev head to this current branch.   
# Ideally you want to run this command from a folder where you want the code to merge to....   
merge()   
{   
BRANCH=$(cat CVS/Tag | cut -c2-)   
CMD=$(echo cvs update -j $BRANCH -j Version_2_17_dev .)   
echo $CMD   
}   
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Change Putty Window Title</title>
      <link>http://abhipandey.com/2013/04/change-putty-window-title/</link>
      <pubDate>Thu, 25 Apr 2013 07:02:00 +0000</pubDate>
      
      <guid>http://abhipandey.com/2013/04/change-putty-window-title/</guid>
      <description>&lt;p&gt;How to modify the Putty window title to a specific string?&lt;/p&gt;

&lt;p&gt;By default, you&amp;rsquo;d like to have the window title to give you the full path to the folder you are working from (working directory). &lt;code&gt;PROMPT_COMMAND&lt;/code&gt;will help you with that.&lt;/p&gt;

&lt;p&gt;However, if you have too many windows where you are on the same folder then it may become confusing. To set your own title you&amp;rsquo;d like to use the &lt;code&gt;title()&lt;/code&gt; function provided here. It sets the name to whatever you say.&lt;/p&gt;

&lt;p&gt;Please note that &lt;code&gt;PS1&lt;/code&gt; is only valid until you move your folders again. That is why the title() function also has to reset &lt;code&gt;PROMPT_COMMAND&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at the script needed. Maybe you wanna put them in your .bashrc file.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;http://gist.github.com/8eed9133ed91cbb42854.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>